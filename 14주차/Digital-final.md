# Digital-final

# 🧑‍💻 6장 - 화소영역처리

- 화소 점 처리 : 해당 화소의 값이나 위치를 통해 값을 변경하는 처리기법
- **`화소 영역 처리`** : 해당 화소 + 주변 화소들의 값이나 위치를 통해 값을 변경하는 처리기법
    - 엠보싱, 블러링, 샤프닝, 엣지 검출, 잡음제거 등..
- 화소영역처리 == `회선처리` == `컨벌루션 처리`
- `회선마스크` : 입력영상과 곱하는 가중치를 행렬로 나타낸 것(새로운 화소 하나 생성시 9개의 가중치가 필요함)
    - 하나의 픽셀 값 = 입력1 * 가중치1 + 입력2 * 가중치 2 + … + 입력9 * 가중치9
    - `홀수 x 홀수`를 만족해야하며 중앙 요소 위치가 출력화소의 위치에 해당한다.
        
        ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled.png)
        
- `엠보싱` : 입력 영상을 양각 형태로 보이게 하는 기술
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%201.png)
    
- `블러링` : 영상의 세밀한 부분(고주파 성분)을 제거하여 영상을 흐리게 + 부드럽게 하는 기술
    - 사용 회선 마스크 : 저역통과필터(LPF)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%202.png)
    
- `샤프닝` : 영상의 상세한 부분을 더욱 강조하여 표현하는 기술(블러링과 반대), 저주파 성분을 제거하면 된다.
    - 사용 회선 마스크 : 고역통과필터(HPF)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%203.png)
    
- `경계선 검출` : 영상의 경계선을 찾아내는 기술, 경계선이라는 것은 밝기의 변화량이 높은 지점에 있으므로 본 처리를 위해선 입력한 영상의 정보가 많이 필요하다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%204.png)
    

---

- 디지털 영상처리 : 선형 시불변 시스템
    - `선형 시불변 시스템` : 선형성을 만족하면서 시간에 따라 변하지 않는 시스템
- `회선 / 컨벌루션 처리` : 선형 시불변 시스템의 입력 신호에서 출력신호를 구하는 방법
    - 디지털 영상처리 ← 선형 시불변 시스템 == 회선 / 컨벌루션 처리
- 회선 수행 방법 : 회선 마스크가 target pixel위를 왼쪽→오른쪽으로 이동하며 연산을 수행한다. 한 행의 연산이 모두 끝나면 다음 행으로 넘어가 연산을 반복한다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%205.png)
    
    - **문제점** : target pixel기준으로 주변 8개의 pixel중 비어있는 특정 부분들이 있다(테두리 부분)
        - `해결방법-1(’0’삽입)` : 비어있는 부분을 0으로 가정하고 회선처리를 수행한다.
            - 장점 : 단순하게 구현할 수 있다.
            - 단점 : 정확하지 않으므로 손상이 발생한다.
        - `해결방법-2(’중첩 부분’에서만 회선 수행)` : 비어있지 않은 target pixel을 대상으로만 회선을 수행하고, 처리하지 않은 pixel들은 이후에 원 값을 대입한다(3x3mask일 경우 (1,1)에서 시작)
        - `해결방법-3(’영상크기조절’하여 회선 수행)` : 영상의 시작과 끝 부분이 연결된 것으로 가정하고 처리하는 방법
            
            ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%206.png)
            
- 회선마스크의 특징
    - 주변 화소의 값을 대칭적으로 고려해야 한다 → 회선 마스크는 무조건 `홀수x홀수` 이다.
    - 출력영상과 입력영상의 `밝기 에너지는 같아야 된다` → 회선 마스크내 `계수의 합은 무조건 1`이다.(**경게선 검출과 같은 일부 회선 마스크는 음수의 계수도 있어야 하기 때문에 계수의 합을 0으로 설계한다**)
    - 💯경계선 검출에 사용하는 회선 마스크의 경우 음의 계수가 있어 몇몇 화소들이 음의 값을 가지는데, 화소는 무조건 0이상의 양의 값만 가져야 하므로 `화소 값에 일정한 상수(최대 밝기 / 2)를 더해서` 양의 값으로 변환시킨다.

---

- `엠보싱(Embossing)`
    - 사용하는 회선 마스크는 경계선 검출 기법의 회선 마스크와 같다(`sum = 0`)
    - 경계 검출로 인해 영상이 볼록한 느낌(양각)을 갖게 된다.
    - sum = 0인 회선 마스크를 사용하면 당연히 `음수인 화소`가 나오는데, 이때는 gray-level영상의 최대 밝기인 255를 2로 나눈 `128을 더해주어` 처리한다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%207.png)
    
    | -1 | 0 | 0 |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 0 | 0 | 1 |
    
    | 0 | 0 | 0 |
    | --- | --- | --- |
    | 0 | 1 | 0 |
    | 0 | 0 | 0 |
    
    | 1 | 1 | 1 |
    | --- | --- | --- |
    | 1 | -8 | 1 |
    | 1 | 1 | 1 |
- `블러링(Blurring)`**(일반적인 처리방법)**
    - 사용하는 회선 마스크는 `sum = 1`이다
    - 회선 마스크의 `각 가중치는 모두 동일한 값`을 가지고 있다(1 / n*n)
    - 회선 마스크의 크기가 커질수록 더욱 경계가 흐려진다(3x3 → 5x5 결과 비교시)
    - 영상에서 세세한 부분의 화소 값은 극단적이기 마련이다. 해당 값을 평준화(평균값 대체)시켜 제거하는 것이 블러링 기법이다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%208.png)
    

| 1/9 | 1/9 | 1/9 |
| --- | --- | --- |
| 1/9 | 1/9 | 1/9 |
| 1/9 | 1/9 | 1/9 |

| 1/25 | 1/25 | 1/25 | 1/25 | 1/25 |
| --- | --- | --- | --- | --- |
| 1/25 | 1/25 | 1/25 | 1/25 | 1/25 |
| 1/25 | 1/25 | 1/25 | 1/25 | 1/25 |
| 1/25 | 1/25 | 1/25 | 1/25 | 1/25 |
| 1/25 | 1/25 | 1/25 | 1/25 | 1/25 |
- `블러링(Blurring) 처리` == `스무딩(Smoothing) 처리` ~= `가우시안 필터 처리`
    - 사용하는 회선마스크 : 가우시안 필터(LPF)(가우시안 함수에서 유도)(`Sum = 1`)
    - 저역 통과 필터(LPF)를 사용하여 고주파 값을 걸러낸다.
        
        ![가우시안 함수 그래프](Digital-final%204d3f455969f94dc3869b65db28893179/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-09_23.42.03.png)
        
        가우시안 함수 그래프
        
    - `σ 크면` : 높이 하향 / 폭 넓어짐 → `많은 저주파 성분 통과`
    - `σ 작으면` : 높이 상향 / 폭 좁아짐 → `적은 저주파 성분 통과`
        
        
        | 1/16 | 1/8 | 1/16 |
        | --- | --- | --- |
        | 1/8 | 1/4 | 1/8 |
        | 1/16 | 1/8 | 1/16 |
- `샤프닝(Sharpening) 처리`
    - 사용하는 회선 마스크는 `sum = 1`이다
    - 블러링과 반대의 효과를 내는 처리방법(흐림 → 선명)
    - 고역 통과 필터(HPF) 혹은 저주파 차단 필터를 사용하여 저주파를 걸러낸다 == 고주파에 해당하는 상세한 부분을 더욱 강조하여 `대비 효과를 증가`시킴
        
        
        | -1 | -1 | -1 |
        | --- | --- | --- |
        | -1 | 9 | -1 |
        | -1 | -1 | -1 |
        
        | 0 | -1 | 0 |
        | --- | --- | --- |
        | -1 | 5 | -1 |
        | 0 | -1 | 0 |
    
    ![스크린샷 2022-12-09 23.53.36.png](Digital-final%204d3f455969f94dc3869b65db28893179/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-09_23.53.36.png)
    

- `샤프닝(Sharpening) 처리` - **고주파 통과 필터 사용**
    - 사용하는 회선 마스크는 `sum = 0`이다(이 부분만 일반 샤프닝과 다름)
    - 일반적인 샤프닝 처리보다 더 많은 저주파 성분이 제거되어 `선명하게 바꾸는걸 넘어 정말로 경계 부분만 확인이 가능`하다.
        
        
        | -1/9 | -1/9 | -1/9 |
        | --- | --- | --- |
        | -1/9 | 8/9 | -1/9 |
        | -1/9 | -1/9 | -1/9 |

---

### ✏️2차원 배열에 관한 학습

- 배열 : array[row][col]
    - row : 제1크기, col : 제2크기
    - col부터 증가하고 이후 row가 증가하는 방식이다.
- 배열의 초기화(중괄호 사용)
    - 2차원 배열 : array[2][3] = {{1, 2, 3}, {4, 5, 6}}
    - 2차원 배열이지만 1차원 배열처럼  array[2][3] = {1, 2, 3, 4, 5, 6}으로 해도 정상적으로 초기화 된다.
    - 초기 값을 생략하면 나머지 원소를 0으로 자동 초기화한다.
    - array[][2] = {1,2,3,4,5,6}(가능), array[3][] = {1,2,3,4,5,6}(불가능) → row(제1크기)만 생략 가능하다.
- 문자열 : 큰 따옴표(””)로 표현, 저장시 문자열의 끝을 알기 위해 ‘\0’(널 문자)를 함께 보관한다
    - 문자열 상수 : 값이 변경되지 않는 문자열(”A”, “Hello, world!”)
    - 문자열 변수(`문자배열`) : 프로그램 수행 중에 변경될 수 있는 문자열
- 문자배열 : 문자열의 길이 + 1 → 문자배열 크기

```cpp
char str[6] = "Hello"; //5글자인데 크기는 6으로 한 것 유의(널 문자 삽입 됨)
char str[4] = "AB"; // A B \0 \0 로 초기화 됨
char str[4] = "ABCD"; //컴파일 경고 발생(컴파일 오류가 아니라 '경고'이다)
char str[3] = ""; // \0 \0 \0 로 초기화 됨(가능)
char str[] = "KWON"; //크기 5로 자동으로 초기화(가능)
```

```cpp
char str[4] = "KHW";
printf("%s", str); //출력방법(for문 사용하지 않아도 출력 가능)
```

```cpp
char str[7] = "KWONHY";
str = "HELL"; //초기화 후 대입 불가능, 특정 함수 이용해야 함
```

- 포인터 배열 : ‘주소’를 저장하는 배열(int* array[4], double* array[3] 이런거)
    - 포인터가 가르키는 원소에 접근하기 위해서는 ‘*’(간접참조연산자) 사용
    - 배열 내 포인터가 있는 것임.

```cpp
int a = 10, b = 20, c = 30;
int* array[3] = {&a, &b, &c}; //포인터 배열은 원소 개수가 곧 크기이다.
//원소 값에 접근 후 출력하려면
for(int i = 0; i < 3; i++){
	printf("%d", *array[i]);
}
```

- 배열에 대한 포인터 : 이차원 배열의 한 묶음(array[0], array[1] …)을 가르키는 용도로 사용
    - 포인터가 배열을 가르키는 것임.

```cpp
int array[3][4] = {{1, 2, 3, 4},
									 {2, 3, 4, 5},
									 {3, 4, 5, 6}};
int (*p)[4] = array //1번 방법
int (*p)[4] = &array[0] //2번 방법
```

---

### ✏️공간 주파수에 관한 학습

- 헤르츠(Hz) : 주파수 표현 단위 / 1초 동안 진동 횟수 / `전파라는 신호에 국한`된 표현
- 확장된 의미의 주파수 : 이벤트가 `주기적으로 재발생 하는 빈도`
    - 저주파 : 밝기 변화가 느림(엉성한 영상)
    - 고주파 : 밝기 변화가 빠름(섬세한 영상)
- 영상처리 : `공간 주파수` 개념(밝기의 변화 정도에 따라 분류)
    - 저주파 영역 : 영상의 배경이나 객체의 내부 부분
    - 고주파 영역 : 경계부분이나 객체의 모서리 부분
    - 저주파 영역 삭제 : 엉성한 부분 사라짐 / 섬세한 부분에 해당하는 경계 강조
    - 고주파 영역 삭제 : 섬세한 부분 사라짐 / 부드럽고 엉성하게 변함

---

# 🧑‍💻 7장 - 에지 검출

- `에지(edge)` : 영상에서 밝기가 낮은 값→높은 값 or 높은 값→낮은 값 으로 변하는 지점(경계선)
    - 물체를 식별하고 위치/모양/크기에 관한 정보를 제공한다.
    
    ![에지의 4가지 종류](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%209.png)
    
    에지의 4가지 종류
    
    ![지붕형 에지의 예시](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2010.png)
    
    지붕형 에지의 예시
    
- `에지 구하는 방법 1 - 이동과 차분 처리`
    - 화소의 위치를 위쪽, 아래쪽, 왼쪽, 오른쪽으로 하나씩 이동시킨 뒤 원래 화소에서 이동 위치의 화소를 빼서 에지를 구함
    - 대부분의 에지 검출이 이 방법을 응용한 것
    - 사용하는 회선 마스크는 `sum = 0`이다
    - 💯수직과 수평 구분 잘하자
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2011.png)
    

- `에지 구하는 방법2 - 유사 연산자 기법`
    - 가장 간단한 에지 검출 방법
    - 중심 화소를 기준으로 이웃 화소를 감산한 값에서 최대 값을 결정하여 에지 검출(`8번 계산`)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2012.png)
    
    - `임계 값`(Threshold) 추가
        - `강한 에지는 강하게`, `약한 에지를 약하게` 함(효율적으로 영상처리하기 위해)

- `에지 구하는 방법3 - 1차 미분`
    - 밝기가 급격히 변하는 부분(==에지) → 변화 부분 탐지연산 → 에지검출
    - 사용하는 회선 마스크는 `sum = 0`이다
        - 로버츠, 프리윗, 소벨 마스크(회선 마스크 표는 생략하겠음 → 중요하지 않음)
        - 💯`로버츠 마스크` : 크기 작아 매우 빠른속도 동작 / 잡음에 민감하고 돌출된 값을 잘 평균할 수 없다.
        - 💯`프리윗 마스크` : 돌출된 값을 잘 평균화 / 대각선보다 수평,수직 에지에 더 민감함
        - 💯`소벨 마스크` : 돌출된 값을 잘 평균화 / 대각선 방향 에지에 더 민감함

- `에지 구하는 방법4 - 2차 미분`
    - `라플라시안 마스크` 사용

---

# 🧑‍💻 8장 - 기하학적 변화

- 기하학적 변환 : 영상을 구성하는 화소의 위치를 `재배치`하는 과정
    - 입력영상 → 출력영상 : `전방향 사상`
    - 출력영상 → 입력영상 : `역방향 사상`
    - `선형 기하 변환` : 선형적 처리 방법(**translation, rotation, scaling**)
    - `비선형 기하 변환` : 영상을 찌그러뜨리고 구부려 곡선으로 처리(**warping, morphing**)
        - 모핑 : **두 개의 서로 다른 이미지의 변화하는 과정을 서서히 나타내는 것**
        - 워핑 : **영상을 찌끄러뜨리는 기법**
- `보간법(Interpolation)` : Scaling(확대/축소) 처리시 값을 할당받지 못하는 화소가 발생하는데, 이 부분에 값을 채워넣는 과정을 말한다.
- 사상(Mapping) : 주어진 조건으로 현재의 데이터를 원하는 목표로 만드는 것
    - `전방향 사상` : 입력영상과 출력영상이 동일한 크기일 때 유용(**But, 고질적인 문제점 2가지**)
        - 오버랩 문제(`영상축소시`) : 서로 다른 입력 화소 두 개가 같은 출력 화소에 사상되는 문제
        - 홀 문제(`영상 확대` 및 `회전시`) : 입력 영상에서 임의의 화소가 목적 영상의 화소에 사상되는 않는 문제
            
            ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2013.png)
            
    - `역방향 사상` : 출력 영상에서 입력 영상의 값을 찾는 것 / 전방향 사상과 반대되는 개념
        - **오버랩, 홀 문제 발생하지 않음**

### 💯역방향 사상시 홀 문제가 발생하지 않는 이유 예시(D(x,y) = O(x/2, y/2))

- 사상함수가 위와같이 정의되어 있을 때, 전방향 사상을 한다면 홀 문제가 발생한다.
    - 입력 영상 홀수 좌표 → 출력 영상 소수점 좌표(== 좌표가 없음)
- 역방향 사상을 한다면, 역함수로 입력 영상의 좌표 값을 계산하고(O(x,y) = D(2x, 2y)) 그 좌표에 해당하는 화소 값을 찾아 출력 영상에 할당하기 때문에 홀 문제가 발생하지 않는다.
    
    ![전방향 사상시 발생하는 홀 문제](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2014.png)
    
    전방향 사상시 발생하는 홀 문제
    
    ![역방향 사상시 해결되는 홀 문제](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2015.png)
    
    역방향 사상시 해결되는 홀 문제
    

---

- `보간법(Interpolation)` : 화소 값을 할당받지 못하는 출력영상의 품질은 매우 좋지 않음 → 할당 받지 못한 곳에 특수한 계산을 통한 값을 할당하여 좋은 품질의 영상을 만드는 방법
- `보간법1 - 가장 인접한 이웃화소 보간법`
    - 값을 할당 받지 못한 출력 영상의 화소에서 가장 가깝게 이웃한 입력 화소의 값을 할당 받은 목적 영상의 화소 값을 복사해서 사용하는 것
    - 단순히 이웃 화소를 복사하기 때문에 처리 속도가 빠르다.
    - 새로운 값을 계산하지 않고 단지 복사하기 때문에 `원래의 영상과 전혀 다른 영상을 출력하는 오류`가 발생한다.(톱니 모양(뭉툭함) 발생)
        
        ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2016.png)
        
- `보간법2 - 양선형 보간법`
    - 입력 영상의 화소 값 두 개를 이용하여 원하는 좌표에서 새로운 화소 값 을 계산하는 간단한 방법
    - 가장 인접한 이웃화소 보간법에 비해 스무딩한 영상을 출력한다. 그러나 `화소당 선형 보간을 세 번씩` 수행해야 하므로 많은 계산이 필요하다.
    - 화소당 `선형 보간을 3번` 수행, `가장 가까운 화소 4개`에 가중치를 곱한 값을 합해서 얻음
        
        ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2017.png)
        
- `보간법3 - 고차 보간법`(더 많은 이웃화소 참조)
    - **3차원 회선 보간법**
        - 4x4의 이웃화소 참조하여 보간
        - 양선형 보간법보다 많은 화소를 참조하므로 품질도 더 좋다
        - 계산 시간이 더 많이 소요된다.
    - **B-스플라인 보간법**
        - 모든 보간함수 중에 가장 스무딩한 영상이 출력된다.
        - 이상적인 보간함수 == 저역통과필터(LPF) == B-스플라인 함수

---

- 스케일링 : 디지털 영상의 모양은 변화시키지 않은 채 크기만을 확대하거나 축소하는 변환

## 확대스케일링

- 💯가장 인접한 이웃화소 보간법 → 스케일링(확대)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2018.png)
    
- 💯양선형 보간법 → 스케일링(확대)
    - 첫번째 화소x0.5 + 두번째 화소x0.5 = 새로운 화소1
    - 첫번째 화소x0.5 + 두번째 화소x0.5 = 새로운 화소2
    - 새로운 화소1x0.5 + 새로운 화소2x0.5 = 새로운 화소3(중앙)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2019.png)
    

## 축소 스케일링

- `축소 스케일링의 문제점` : `에일리어싱(Aliasing)` → 영상 처리 후, 픽셀 값의 소실로 인해 선의 경계가 계단처럼 보이는 현상
    - 해결방안 : `축소 전` LPF 통과시켜 `블러링(Blurring) 수행`하면 됨.
- `미디언 서브 샘플링` : 화소를 중간 값(일렬로 나열해서 중간에 위치한 값)으로 대치하여 출력 영상의 화소로 사용하는 방법
    - 블러링 후 단순 서브 샘플링 하는 것 보다 화질이 선명하다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2020.png)
    

- `평균 서브 샘플링` : 미디언이 값을 일렬로 나열하여 중간의 위치한 값을 취하는 방법이었다면, 평균 서브 샘플링은 진짜 평균 값을 구하여 대치하는 방법이다.
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2021.png)
    
- 미디언 서브 샘플링(bad) vs 평균 서브 샘플링(good)

![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2022.png)

---

# 🧑‍💻 9장 - 이동, 대칭, 회전

- 이동 : 영상을 평면의 한 위치에서 원하는 다른 위치로 옮기는 연산 / 크기나 형태 등이 바뀌지 않고 원본 영상과 결과 같음
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2023.png)
    
- 대칭 : 영상을 가로축이나 세로축으로 뒤집는 것
    - 세로축 뒤집기 : `좌우 대칭`(x0 = 세로축)
    
    ```cpp
    for (i = 0; i < m_height; i++) {
    		for (j = 0; j < m_width; j++) {
    			m_OutputImage[i * m_width + (m_width - j - 1)] = 
    			m_InputImage[i * m_width + j];
    		}
    	}
    ```
    
    - 가로축 뒤집기 : `상하 대칭`(y0 = 가로축)
    
    ```cpp
    for (i = 0; i < m_height; i++) {
    		for (j = 0; j < m_width; j++) {
    			m_OutputImage[(m_height - i - 1) * m_width + j] = 
    			m_InputImage[i * m_width + j];
    		}
    	}
    ```
    
- 회전 : 영상을 임의의 방향으로 특정한 각도만큼 회전시키는 연산을 말한다.
    - **회전**에 필요한 **3요소** : `기준점`, `각도`, `회전방향`

- `직교 좌표계` : 현재 우리가 쓰고 있는 일반적인 좌표 시스템(2차원)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2024.png)
    

- `극 좌표계` : 2차원에서 임의의 점을 r과 θ 로 표시하는 좌표 시스템
    - r : 원점으로부터의 거리
    - θ : x축으로부터 반 시계방향으로 기울어진 각도
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2025.png)
    
    ## 💯회전을 가정하여 좌표 계산 해보자
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2026.png)
    
- cos(α+β)=cosαcosβ - sinαsinβ(상식)(코코싸싸)
- sin(α+β) = sinαcosβ + cosαsinβ(상식)(싸코코싸)

### x = ρ cos(Ø)

### y = ρ sin(Ø)

### x’ = ρ cos(Ø+θ) = xcosθ - ysinθ

### y’ = ρ sin(Ø+θ) = xsinθ + ycosθ

![필수암기](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2027.png)

필수암기

---

- 회전 처리 → `홀 문제 발생`
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2028.png)
    

- 홀 문제 해결방안 → **2가지**
    1. `역방향 사상`
    2. `중심에서 회전`
- 역방향 사상 + 중심회전 공식화(C는 회전중심)
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2029.png)
    
- 수학 좌표와 화면 좌표계는 다르다
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2030.png)
    
- 올바른 회전 : **화면 좌표를 수학적 좌표로 변환하여 회전한 뒤 다시 화면 좌표로 변환해야 함**
- 출력 영상에서 잘리는 부분이 없게 하려면? → 출력 영상의 크기를 다시 고려해야한다
    - **우리가 제작한 프로그램에서는 반영하지 않은 부분임**
    - 아래 공식이 새로운 이미지 크기 계산하는 공식(W = 너비, H = 높이)
    
    ![스크린샷 2022-12-11 23.57.07.png](Digital-final%204d3f455969f94dc3869b65db28893179/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_23.57.07.png)
    

---

# 🧑‍💻 10장 - 프레임 처리

- `프레임 처리` : 두 개 이상의 서로 다른 영상으로 새로운 화소 값을 연산하여 생성하는 것 / 각 연산된 화소는 기존의 위치와 같은 위치에 생성된다.
- 프레임 결합처리 : 서로 관련있는 복수의 영상을 합성하여 향상된 품질의 영상을 만드는 것
- 💯그냥 프레임 연산을 하면 될 것이지 `α변수를 도입하여 연산하는 이유?`
    - `오버플로 방지하기 위해`
- 프레임 덧셈 연산 : 가장 간단한 두 영상의 합성 / 특정 부분을 강조
- 프레임 뺄셈 연산 : 영상의 변화를 검출하는데 효과적 / 배경제거 / 감시 시스템 / 검사 시스템/ 잡음제거
- 프레임 AND 연산 : 영상의 특정 부분을 상쇄하는데 사용
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2031.png)
    

- 프레임 OR 연산 : 영상 하나에 다른 영상의 특정 부분을 추가할 때 사용
    
    ![Untitled](Digital-final%204d3f455969f94dc3869b65db28893179/Untitled%2032.png)
    

---

# OpenCV미포함 / 히스토그램(5장) 미포함